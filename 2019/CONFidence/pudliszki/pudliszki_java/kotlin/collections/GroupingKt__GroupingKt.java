package kotlin.collections;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import kotlin.Metadata;
import kotlin.SinceKotlin;
import kotlin.jvm.functions.Function2;
import kotlin.jvm.functions.Function3;
import kotlin.jvm.functions.Function4;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;


























































@Metadata(mv={1, 1, 13}, bv={1, 0, 3}, k=5, xi=1, d1={"\000@\n\000\n\002\020$\n\002\b\003\n\002\030\002\n\000\n\002\030\002\n\002\030\002\n\002\b\004\n\002\020\013\n\002\b\003\n\002\020%\n\002\b\003\n\002\020\b\n\002\b\003\n\002\030\002\n\002\030\002\n\002\b\n\032\001\020\000\032\016\022\004\022\002H\002\022\004\022\002H\0030\001\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003*\016\022\004\022\002H\004\022\004\022\002H\0020\0052b\020\006\032^\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\025\022\023\030\001H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\023\022\0210\r¢\006\f\b\b\022\b\b\t\022\004\b\b(\016\022\004\022\002H\0030\007H\b\032´\001\020\017\032\002H\020\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003\"\026\b\003\020\020*\020\022\006\b\000\022\002H\002\022\004\022\002H\0030\021*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\022\032\002H\0202b\020\006\032^\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\025\022\023\030\001H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\023\022\0210\r¢\006\f\b\b\022\b\b\t\022\004\b\b(\016\022\004\022\002H\0030\007H\b¢\006\002\020\023\032I\020\024\032\002H\020\"\004\b\000\020\004\"\004\b\001\020\002\"\026\b\002\020\020*\020\022\006\b\000\022\002H\002\022\004\022\0020\0250\021*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\022\032\002H\020H\007¢\006\002\020\026\032¼\001\020\027\032\016\022\004\022\002H\002\022\004\022\002H\0030\001\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003*\016\022\004\022\002H\004\022\004\022\002H\0020\00526\020\030\0322\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\0312K\020\006\032G\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\032H\b\032|\020\027\032\016\022\004\022\002H\002\022\004\022\002H\0030\001\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\033\032\002H\00326\020\006\0322\022\023\022\021H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\031H\b¢\006\002\020\034\032Õ\001\020\035\032\002H\020\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003\"\026\b\003\020\020*\020\022\006\b\000\022\002H\002\022\004\022\002H\0030\021*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\022\032\002H\02026\020\030\0322\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\0312K\020\006\032G\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\032H\b¢\006\002\020\036\032\001\020\035\032\002H\020\"\004\b\000\020\004\"\004\b\001\020\002\"\004\b\002\020\003\"\026\b\003\020\020*\020\022\006\b\000\022\002H\002\022\004\022\002H\0030\021*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\022\032\002H\0202\006\020\033\032\002H\00326\020\006\0322\022\023\022\021H\003¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H\0030\031H\b¢\006\002\020\037\032\001\020 \032\016\022\004\022\002H\002\022\004\022\002H!0\001\"\004\b\000\020!\"\b\b\001\020\004*\002H!\"\004\b\002\020\002*\016\022\004\022\002H\004\022\004\022\002H\0020\0052K\020\006\032G\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H!¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H!0\032H\b\032¡\001\020\"\032\002H\020\"\004\b\000\020!\"\b\b\001\020\004*\002H!\"\004\b\002\020\002\"\026\b\003\020\020*\020\022\006\b\000\022\002H\002\022\004\022\002H!0\021*\016\022\004\022\002H\004\022\004\022\002H\0020\0052\006\020\022\032\002H\0202K\020\006\032G\022\023\022\021H\002¢\006\f\b\b\022\b\b\t\022\004\b\b(\n\022\023\022\021H!¢\006\f\b\b\022\b\b\t\022\004\b\b(\013\022\023\022\021H\004¢\006\f\b\b\022\b\b\t\022\004\b\b(\f\022\004\022\002H!0\032H\b¢\006\002\020#¨\006$"}, d2={"aggregate", "", "K", "R", "T", "Lkotlin/collections/Grouping;", "operation", "Lkotlin/Function4;", "Lkotlin/ParameterName;", "name", "key", "accumulator", "element", "", "first", "aggregateTo", "M", "", "destination", "(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function4;)Ljava/util/Map;", "eachCountTo", "", "(Lkotlin/collections/Grouping;Ljava/util/Map;)Ljava/util/Map;", "fold", "initialValueSelector", "Lkotlin/Function2;", "Lkotlin/Function3;", "initialValue", "(Lkotlin/collections/Grouping;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;", "foldTo", "(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;", "(Lkotlin/collections/Grouping;Ljava/util/Map;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;", "reduce", "S", "reduceTo", "(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;", "kotlin-stdlib"}, xs="kotlin/collections/GroupingKt")
class GroupingKt__GroupingKt
  extends GroupingKt__GroupingJVMKt
{
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R, M extends Map<? super K, R>> M aggregateTo(@NotNull Grouping<T, ? extends K> $receiver, @NotNull M destination, @NotNull Function4<? super K, ? super R, ? super T, ? super Boolean, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(destination, "destination");Intrinsics.checkParameterIsNotNull(operation, "operation");Iterator localIterator2 = $receiver.sourceIterator(); Object key; Map localMap; Object localObject1; for (Iterator localIterator1 = localIterator2; localIterator1.hasNext(); 
        

        localMap.put(key, localObject1))
    {
      Object e = localIterator1.next();
      key = $receiver.keyOf(e);
      Object accumulator = destination.get(key);
      localMap = destination;localObject1 = operation.invoke(key, accumulator, e, Boolean.valueOf((accumulator == null) && (!destination.containsKey(key))));
    }
    return destination;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R> Map<K, R> aggregate(@NotNull Grouping<T, ? extends K> $receiver, @NotNull Function4<? super K, ? super R, ? super T, ? super Boolean, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping localGrouping1 = $receiver;Map localMap1 = (Map)new LinkedHashMap();
    


























































    int $i$f$aggregateTo;
    


























































    Map destination$iv;
    


























































    Grouping $receiver$iv;
    

























































    Iterator localIterator1 = $receiver$iv.sourceIterator(); Object key$iv; Map localMap2; Object localObject1; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); 
        

        localMap2.put(key$iv, localObject1))
    {
      Object e$iv = localIterator2.next();
      key$iv = $receiver$iv.keyOf(e$iv);
      Object accumulator$iv = destination$iv.get(key$iv);
      localMap2 = destination$iv;localObject1 = operation.invoke(key$iv, accumulator$iv, e$iv, Boolean.valueOf((accumulator$iv == null) && (!destination$iv.containsKey(key$iv))));
    }
    return destination$iv;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R> Map<K, R> fold(@NotNull Grouping<T, ? extends K> $receiver, @NotNull Function2<? super K, ? super T, ? extends R> initialValueSelector, @NotNull Function3<? super K, ? super R, ? super T, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(initialValueSelector, "initialValueSelector");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    



























































































    int $i$f$aggregate;
    



























































































    Grouping localGrouping1 = $receiver$iv;Map localMap1 = (Map)new LinkedHashMap();
    int $i$f$aggregateTo; Map destination$iv$iv; Grouping $receiver$iv$iv; Iterator localIterator1 = $receiver$iv$iv.sourceIterator(); Object key$iv$iv; Map localMap2; Object localObject3; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap2.put(key$iv$iv, localObject3))
    {

























































































































































































      Object e$iv$iv = localIterator2.next();
      key$iv$iv = $receiver$iv$iv.keyOf(e$iv$iv);
      Object accumulator$iv$iv = destination$iv$iv.get(key$iv$iv);
      localMap2 = destination$iv$iv;int i = (accumulator$iv$iv == null) && (!destination$iv$iv.containsKey(key$iv$iv)) ? 1 : 0;Object localObject1 = e$iv$iv;Object localObject2 = accumulator$iv$iv;Object key = key$iv$iv;
      int $i$a$1$aggregate;
      Object acc;
      Object e;
      boolean first;
      localObject3 = operation.invoke(key, first ? initialValueSelector.invoke(key, e) : acc, e); } return 
    






























































































































































































      destination$iv$iv;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R, M extends Map<? super K, R>> M foldTo(@NotNull Grouping<T, ? extends K> $receiver, @NotNull M destination, @NotNull Function2<? super K, ? super T, ? extends R> initialValueSelector, @NotNull Function3<? super K, ? super R, ? super T, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(destination, "destination");Intrinsics.checkParameterIsNotNull(initialValueSelector, "initialValueSelector");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    















































































    int $i$f$aggregateTo;
    















































































    Iterator localIterator1 = $receiver$iv.sourceIterator(); Object key$iv; Map localMap; Object key; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap.put(key$iv, key))
    {
































































































































































      Object e$iv = localIterator2.next();
      key$iv = $receiver$iv.keyOf(e$iv);
      Object accumulator$iv = destination.get(key$iv);
      localMap = destination;int i = (accumulator$iv == null) && (!destination.containsKey(key$iv)) ? 1 : 0;Object localObject1 = e$iv;Object localObject2 = accumulator$iv;key = key$iv;
      int $i$a$1$aggregateTo;
      Object acc;
      Object e;
      boolean first;
      key = operation.invoke(key, first ? initialValueSelector.invoke(key, e) : acc, e); } return 
    





































































































































































      destination;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R> Map<K, R> fold(@NotNull Grouping<T, ? extends K> $receiver, R initialValue, @NotNull Function2<? super R, ? super T, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    








































































    int $i$f$aggregate;
    







































































    Grouping localGrouping1 = $receiver$iv;Map localMap1 = (Map)new LinkedHashMap();
    int $i$f$aggregateTo; Map destination$iv$iv; Grouping $receiver$iv$iv; Iterator localIterator1 = $receiver$iv$iv.sourceIterator(); Object key$iv$iv; Map localMap2; Object localObject3; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap2.put(key$iv$iv, localObject3))
    {


















































































































































      Object e$iv$iv = localIterator2.next();
      key$iv$iv = $receiver$iv$iv.keyOf(e$iv$iv);
      Object accumulator$iv$iv = destination$iv$iv.get(key$iv$iv);
      localMap2 = destination$iv$iv;int i = (accumulator$iv$iv == null) && (!destination$iv$iv.containsKey(key$iv$iv)) ? 1 : 0;Object localObject1 = e$iv$iv;Object localObject2 = accumulator$iv$iv;Object $noName_0 = key$iv$iv;
      int $i$a$2$aggregate;
      Object acc;
      Object e;
      boolean first;
      localObject3 = operation.invoke(first ? initialValue : acc, e); } return 
    























































































































































      destination$iv$iv;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, R, M extends Map<? super K, R>> M foldTo(@NotNull Grouping<T, ? extends K> $receiver, @NotNull M destination, R initialValue, @NotNull Function2<? super R, ? super T, ? extends R> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(destination, "destination");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    































































    int $i$f$aggregateTo;
    






























































    Iterator localIterator1 = $receiver$iv.sourceIterator(); Object key$iv; Map localMap; Object $noName_0; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap.put(key$iv, $noName_0))
    {































































































































      Object e$iv = localIterator2.next();
      key$iv = $receiver$iv.keyOf(e$iv);
      Object accumulator$iv = destination.get(key$iv);
      localMap = destination;int i = (accumulator$iv == null) && (!destination.containsKey(key$iv)) ? 1 : 0;Object localObject1 = e$iv;Object localObject2 = accumulator$iv;$noName_0 = key$iv;
      int $i$a$2$aggregateTo;
      Object acc;
      Object e;
      boolean first;
      $noName_0 = operation.invoke(first ? initialValue : acc, e); } return 
    




































































































































      destination;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <S, T extends S, K> Map<K, S> reduce(@NotNull Grouping<T, ? extends K> $receiver, @NotNull Function3<? super K, ? super S, ? super T, ? extends S> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    























































    int $i$f$aggregate;
    






















































    Grouping localGrouping1 = $receiver$iv;Map localMap1 = (Map)new LinkedHashMap();
    int $i$f$aggregateTo; Map destination$iv$iv; Grouping $receiver$iv$iv; Iterator localIterator1 = $receiver$iv$iv.sourceIterator(); Object key$iv$iv; Map localMap2; Object localObject3; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap2.put(key$iv$iv, localObject3))
    {














































































































      Object e$iv$iv = localIterator2.next();
      key$iv$iv = $receiver$iv$iv.keyOf(e$iv$iv);
      Object accumulator$iv$iv = destination$iv$iv.get(key$iv$iv);
      localMap2 = destination$iv$iv;int i = (accumulator$iv$iv == null) && (!destination$iv$iv.containsKey(key$iv$iv)) ? 1 : 0;Object localObject1 = e$iv$iv;Object localObject2 = accumulator$iv$iv;Object key = key$iv$iv;
      int $i$a$1$aggregate;
      Object acc;
      Object e;
      boolean first;
      localObject3 = first ? e : operation.invoke(key, acc, e); }
    return 
    


















































































































      destination$iv$iv;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <S, T extends S, K, M extends Map<? super K, S>> M reduceTo(@NotNull Grouping<T, ? extends K> $receiver, @NotNull M destination, @NotNull Function3<? super K, ? super S, ? super T, ? extends S> operation)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(destination, "destination");Intrinsics.checkParameterIsNotNull(operation, "operation");Grouping $receiver$iv = $receiver;
    












































    int $i$f$aggregateTo;
    












































    Iterator localIterator1 = $receiver$iv.sourceIterator(); Object key$iv; Map localMap; Object key; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap.put(key$iv, key))
    {
























































































      Object e$iv = localIterator2.next();
      key$iv = $receiver$iv.keyOf(e$iv);
      Object accumulator$iv = destination.get(key$iv);
      localMap = destination;int i = (accumulator$iv == null) && (!destination.containsKey(key$iv)) ? 1 : 0;Object localObject1 = e$iv;Object localObject2 = accumulator$iv;key = key$iv;
      int $i$a$1$aggregateTo;
      Object acc;
      Object e;
      boolean first;
      key = first ? e : operation.invoke(key, acc, e); }
    return 
    




























































































      destination;
  }
  
  @SinceKotlin(version="1.1")
  @NotNull
  public static final <T, K, M extends Map<? super K, Integer>> M eachCountTo(@NotNull Grouping<T, ? extends K> $receiver, @NotNull M destination)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(destination, "destination");Grouping localGrouping1 = $receiver;Object initialValue$iv = Integer.valueOf(0);
    

























    int $i$f$foldTo;
    

























    Grouping $receiver$iv;
    

























    Grouping $receiver$iv$iv = $receiver$iv;
    int $i$f$aggregateTo; Iterator localIterator1 = $receiver$iv$iv.sourceIterator(); Object key$iv$iv; Map localMap; Object $noName_0$iv; for (Iterator localIterator2 = localIterator1; localIterator2.hasNext(); localMap.put(key$iv$iv, $noName_0$iv))
    {
















































































      Object e$iv$iv = localIterator2.next();
      key$iv$iv = $receiver$iv$iv.keyOf(e$iv$iv);
      Object accumulator$iv$iv = destination.get(key$iv$iv);
      localMap = destination;int i = (accumulator$iv$iv == null) && (!destination.containsKey(key$iv$iv)) ? 1 : 0;Object localObject1 = e$iv$iv;Object localObject2 = accumulator$iv$iv;$noName_0$iv = key$iv$iv;
      int $i$a$2$aggregateTo;
      Object acc$iv;
      Object e$iv;
      boolean first$iv;
      Object localObject3 = e$iv;int acc = ((Number)(first$iv ? initialValue$iv : acc$iv)).intValue();
      int $i$a$1$foldTo;
      Object $noName_1;
      $noName_0$iv = Integer.valueOf(acc + 1); } return 
    





















































































      destination;
  }
  
  public GroupingKt__GroupingKt() {}
}
