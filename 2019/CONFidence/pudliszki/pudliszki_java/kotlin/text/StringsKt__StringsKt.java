package kotlin.text;

import java.util.Collection;
import kotlin.internal.InlineOnly;
import kotlin.jvm.functions.Function1;
import kotlin.jvm.internal.Intrinsics;
import kotlin.ranges.IntRange;
import org.jetbrains.annotations.NotNull;

@kotlin.Metadata(mv={1, 1, 13}, bv={1, 0, 3}, k=5, xi=1, d1={"\000|\n\000\n\002\030\002\n\002\020\r\n\002\b\003\n\002\020\b\n\002\b\003\n\002\020\016\n\002\b\002\n\002\020\013\n\002\b\003\n\002\020\f\n\000\n\002\030\002\n\002\b\003\n\002\030\002\n\000\n\002\020\036\n\002\b\n\n\002\030\002\n\002\b\b\n\002\020\031\n\002\b\006\n\002\030\002\n\002\b\003\n\002\030\002\n\000\n\002\020 \n\002\b\b\n\002\020\021\n\002\b\017\n\002\030\002\n\002\030\002\n\002\b\033\032\034\020\t\032\0020\n*\0020\0022\006\020\013\032\0020\0022\b\b\002\020\f\032\0020\r\032\034\020\016\032\0020\n*\0020\0022\006\020\013\032\0020\0022\b\b\002\020\f\032\0020\r\032\037\020\017\032\0020\r*\0020\0022\006\020\020\032\0020\0212\b\b\002\020\f\032\0020\rH\002\032\037\020\017\032\0020\r*\0020\0022\006\020\013\032\0020\0022\b\b\002\020\f\032\0020\rH\002\032\025\020\017\032\0020\r*\0020\0022\006\020\022\032\0020\023H\n\032\034\020\024\032\0020\r*\0020\0022\006\020\020\032\0020\0212\b\b\002\020\f\032\0020\r\032\034\020\024\032\0020\r*\0020\0022\006\020\025\032\0020\0022\b\b\002\020\f\032\0020\r\032:\020\026\032\020\022\004\022\0020\006\022\004\022\0020\n\030\0010\027*\0020\0022\f\020\030\032\b\022\004\022\0020\n0\0312\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032E\020\026\032\020\022\004\022\0020\006\022\004\022\0020\n\030\0010\027*\0020\0022\f\020\030\032\b\022\004\022\0020\n0\0312\006\020\032\032\0020\0062\006\020\f\032\0020\r2\006\020\033\032\0020\rH\002¢\006\002\b\034\032:\020\035\032\020\022\004\022\0020\006\022\004\022\0020\n\030\0010\027*\0020\0022\f\020\030\032\b\022\004\022\0020\n0\0312\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032\022\020\036\032\0020\r*\0020\0022\006\020\037\032\0020\006\0324\020 \032\002H!\"\f\b\000\020\"*\0020\002*\002H!\"\004\b\001\020!*\002H\"2\f\020#\032\b\022\004\022\002H!0$H\b¢\006\002\020%\0324\020&\032\002H!\"\f\b\000\020\"*\0020\002*\002H!\"\004\b\001\020!*\002H\"2\f\020#\032\b\022\004\022\002H!0$H\b¢\006\002\020%\032&\020'\032\0020\006*\0020\0022\006\020\020\032\0020\0212\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032;\020'\032\0020\006*\0020\0022\006\020\013\032\0020\0022\006\020\032\032\0020\0062\006\020(\032\0020\0062\006\020\f\032\0020\r2\b\b\002\020\033\032\0020\rH\002¢\006\002\b)\032&\020'\032\0020\006*\0020\0022\006\020*\032\0020\n2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032&\020+\032\0020\006*\0020\0022\006\020,\032\0020-2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032,\020+\032\0020\006*\0020\0022\f\020\030\032\b\022\004\022\0020\n0\0312\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032\r\020.\032\0020\r*\0020\002H\b\032\r\020/\032\0020\r*\0020\002H\b\032\r\0200\032\0020\r*\0020\002H\b\032 \0201\032\0020\r*\004\030\0010\002H\b\002\016\n\f\b\000\022\002\030\001\032\004\b\003\020\000\032 \0202\032\0020\r*\004\030\0010\002H\b\002\016\n\f\b\000\022\002\030\001\032\004\b\003\020\000\032\r\0203\032\00204*\0020\002H\002\032&\0205\032\0020\006*\0020\0022\006\020\020\032\0020\0212\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032&\0205\032\0020\006*\0020\0022\006\020*\032\0020\n2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032&\0206\032\0020\006*\0020\0022\006\020,\032\0020-2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032,\0206\032\0020\006*\0020\0022\f\020\030\032\b\022\004\022\0020\n0\0312\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032\020\0207\032\b\022\004\022\0020\n08*\0020\002\032\020\0209\032\b\022\004\022\0020\n0:*\0020\002\032\025\020;\032\0020\r*\0020\0022\006\020\022\032\0020\023H\f\032\017\020<\032\0020\n*\004\030\0010\nH\b\032\034\020=\032\0020\002*\0020\0022\006\020>\032\0020\0062\b\b\002\020?\032\0020\021\032\034\020=\032\0020\n*\0020\n2\006\020>\032\0020\0062\b\b\002\020?\032\0020\021\032\034\020@\032\0020\002*\0020\0022\006\020>\032\0020\0062\b\b\002\020?\032\0020\021\032\034\020@\032\0020\n*\0020\n2\006\020>\032\0020\0062\b\b\002\020?\032\0020\021\032G\020A\032\b\022\004\022\0020\00108*\0020\0022\016\020B\032\n\022\006\b\001\022\0020\n0C2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006H\002¢\006\004\bE\020F\032=\020A\032\b\022\004\022\0020\00108*\0020\0022\006\020B\032\0020-2\b\b\002\020\032\032\0020\0062\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006H\002¢\006\002\bE\0324\020G\032\0020\r*\0020\0022\006\020H\032\0020\0062\006\020\013\032\0020\0022\006\020I\032\0020\0062\006\020>\032\0020\0062\006\020\f\032\0020\rH\000\032\022\020J\032\0020\002*\0020\0022\006\020K\032\0020\002\032\022\020J\032\0020\n*\0020\n2\006\020K\032\0020\002\032\032\020L\032\0020\002*\0020\0022\006\020\032\032\0020\0062\006\020(\032\0020\006\032\022\020L\032\0020\002*\0020\0022\006\020M\032\0020\001\032\035\020L\032\0020\n*\0020\n2\006\020\032\032\0020\0062\006\020(\032\0020\006H\b\032\025\020L\032\0020\n*\0020\n2\006\020M\032\0020\001H\b\032\022\020N\032\0020\002*\0020\0022\006\020\025\032\0020\002\032\022\020N\032\0020\n*\0020\n2\006\020\025\032\0020\002\032\022\020O\032\0020\002*\0020\0022\006\020P\032\0020\002\032\032\020O\032\0020\002*\0020\0022\006\020K\032\0020\0022\006\020\025\032\0020\002\032\022\020O\032\0020\n*\0020\n2\006\020P\032\0020\002\032\032\020O\032\0020\n*\0020\n2\006\020K\032\0020\0022\006\020\025\032\0020\002\032+\020Q\032\0020\n*\0020\0022\006\020\022\032\0020\0232\024\b\b\020R\032\016\022\004\022\0020T\022\004\022\0020\0020SH\b\032\035\020Q\032\0020\n*\0020\0022\006\020\022\032\0020\0232\006\020U\032\0020\nH\b\032$\020V\032\0020\n*\0020\n2\006\020P\032\0020\0212\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020V\032\0020\n*\0020\n2\006\020P\032\0020\n2\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020X\032\0020\n*\0020\n2\006\020P\032\0020\0212\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020X\032\0020\n*\0020\n2\006\020P\032\0020\n2\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020Y\032\0020\n*\0020\n2\006\020P\032\0020\0212\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020Y\032\0020\n*\0020\n2\006\020P\032\0020\n2\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020Z\032\0020\n*\0020\n2\006\020P\032\0020\0212\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032$\020Z\032\0020\n*\0020\n2\006\020P\032\0020\n2\006\020U\032\0020\n2\b\b\002\020W\032\0020\n\032\035\020[\032\0020\n*\0020\0022\006\020\022\032\0020\0232\006\020U\032\0020\nH\b\032\"\020\\\032\0020\002*\0020\0022\006\020\032\032\0020\0062\006\020(\032\0020\0062\006\020U\032\0020\002\032\032\020\\\032\0020\002*\0020\0022\006\020M\032\0020\0012\006\020U\032\0020\002\032%\020\\\032\0020\n*\0020\n2\006\020\032\032\0020\0062\006\020(\032\0020\0062\006\020U\032\0020\002H\b\032\035\020\\\032\0020\n*\0020\n2\006\020M\032\0020\0012\006\020U\032\0020\002H\b\032=\020]\032\b\022\004\022\0020\n0:*\0020\0022\022\020B\032\n\022\006\b\001\022\0020\n0C\"\0020\n2\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006¢\006\002\020^\0320\020]\032\b\022\004\022\0020\n0:*\0020\0022\n\020B\032\0020-\"\0020\0212\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006\032/\020]\032\b\022\004\022\0020\n0:*\0020\0022\006\020P\032\0020\n2\006\020\f\032\0020\r2\006\020D\032\0020\006H\002¢\006\002\b_\032%\020]\032\b\022\004\022\0020\n0:*\0020\0022\006\020\022\032\0020\0232\b\b\002\020D\032\0020\006H\b\032=\020`\032\b\022\004\022\0020\n08*\0020\0022\022\020B\032\n\022\006\b\001\022\0020\n0C\"\0020\n2\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006¢\006\002\020a\0320\020`\032\b\022\004\022\0020\n08*\0020\0022\n\020B\032\0020-\"\0020\0212\b\b\002\020\f\032\0020\r2\b\b\002\020D\032\0020\006\032\034\020b\032\0020\r*\0020\0022\006\020\020\032\0020\0212\b\b\002\020\f\032\0020\r\032\034\020b\032\0020\r*\0020\0022\006\020K\032\0020\0022\b\b\002\020\f\032\0020\r\032$\020b\032\0020\r*\0020\0022\006\020K\032\0020\0022\006\020\032\032\0020\0062\b\b\002\020\f\032\0020\r\032\022\020c\032\0020\002*\0020\0022\006\020M\032\0020\001\032\035\020c\032\0020\002*\0020\n2\006\020d\032\0020\0062\006\020e\032\0020\006H\b\032\037\020f\032\0020\n*\0020\0022\006\020\032\032\0020\0062\b\b\002\020(\032\0020\006H\b\032\022\020f\032\0020\n*\0020\0022\006\020M\032\0020\001\032\022\020f\032\0020\n*\0020\n2\006\020M\032\0020\001\032\034\020g\032\0020\n*\0020\n2\006\020P\032\0020\0212\b\b\002\020W\032\0020\n\032\034\020g\032\0020\n*\0020\n2\006\020P\032\0020\n2\b\b\002\020W\032\0020\n\032\034\020h\032\0020\n*\0020\n2\006\020P\032\0020\0212\b\b\002\020W\032\0020\n\032\034\020h\032\0020\n*\0020\n2\006\020P\032\0020\n2\b\b\002\020W\032\0020\n\032\034\020i\032\0020\n*\0020\n2\006\020P\032\0020\0212\b\b\002\020W\032\0020\n\032\034\020i\032\0020\n*\0020\n2\006\020P\032\0020\n2\b\b\002\020W\032\0020\n\032\034\020j\032\0020\n*\0020\n2\006\020P\032\0020\0212\b\b\002\020W\032\0020\n\032\034\020j\032\0020\n*\0020\n2\006\020P\032\0020\n2\b\b\002\020W\032\0020\n\032\n\020k\032\0020\002*\0020\002\032!\020k\032\0020\002*\0020\0022\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020k\032\0020\002*\0020\0022\n\020,\032\0020-\"\0020\021\032\r\020k\032\0020\n*\0020\nH\b\032!\020k\032\0020\n*\0020\n2\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020k\032\0020\n*\0020\n2\n\020,\032\0020-\"\0020\021\032\n\020m\032\0020\002*\0020\002\032!\020m\032\0020\002*\0020\0022\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020m\032\0020\002*\0020\0022\n\020,\032\0020-\"\0020\021\032\r\020m\032\0020\n*\0020\nH\b\032!\020m\032\0020\n*\0020\n2\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020m\032\0020\n*\0020\n2\n\020,\032\0020-\"\0020\021\032\n\020n\032\0020\002*\0020\002\032!\020n\032\0020\002*\0020\0022\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020n\032\0020\002*\0020\0022\n\020,\032\0020-\"\0020\021\032\r\020n\032\0020\n*\0020\nH\b\032!\020n\032\0020\n*\0020\n2\022\020l\032\016\022\004\022\0020\021\022\004\022\0020\r0SH\b\032\026\020n\032\0020\n*\0020\n2\n\020,\032\0020-\"\0020\021\"\025\020\000\032\0020\001*\0020\0028F¢\006\006\032\004\b\003\020\004\"\025\020\005\032\0020\006*\0020\0028F¢\006\006\032\004\b\007\020\b¨\006o"}, d2={"indices", "Lkotlin/ranges/IntRange;", "", "getIndices", "(Ljava/lang/CharSequence;)Lkotlin/ranges/IntRange;", "lastIndex", "", "getLastIndex", "(Ljava/lang/CharSequence;)I", "commonPrefixWith", "", "other", "ignoreCase", "", "commonSuffixWith", "contains", "char", "", "regex", "Lkotlin/text/Regex;", "endsWith", "suffix", "findAnyOf", "Lkotlin/Pair;", "strings", "", "startIndex", "last", "findAnyOf$StringsKt__StringsKt", "findLastAnyOf", "hasSurrogatePairAt", "index", "ifBlank", "R", "C", "defaultValue", "Lkotlin/Function0;", "(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;", "ifEmpty", "indexOf", "endIndex", "indexOf$StringsKt__StringsKt", "string", "indexOfAny", "chars", "", "isEmpty", "isNotBlank", "isNotEmpty", "isNullOrBlank", "isNullOrEmpty", "iterator", "Lkotlin/collections/CharIterator;", "lastIndexOf", "lastIndexOfAny", "lineSequence", "Lkotlin/sequences/Sequence;", "lines", "", "matches", "orEmpty", "padEnd", "length", "padChar", "padStart", "rangesDelimitedBy", "delimiters", "", "limit", "rangesDelimitedBy$StringsKt__StringsKt", "(Ljava/lang/CharSequence;[Ljava/lang/String;IZI)Lkotlin/sequences/Sequence;", "regionMatchesImpl", "thisOffset", "otherOffset", "removePrefix", "prefix", "removeRange", "range", "removeSuffix", "removeSurrounding", "delimiter", "replace", "transform", "Lkotlin/Function1;", "Lkotlin/text/MatchResult;", "replacement", "replaceAfter", "missingDelimiterValue", "replaceAfterLast", "replaceBefore", "replaceBeforeLast", "replaceFirst", "replaceRange", "split", "(Ljava/lang/CharSequence;[Ljava/lang/String;ZI)Ljava/util/List;", "split$StringsKt__StringsKt", "splitToSequence", "(Ljava/lang/CharSequence;[Ljava/lang/String;ZI)Lkotlin/sequences/Sequence;", "startsWith", "subSequence", "start", "end", "substring", "substringAfter", "substringAfterLast", "substringBefore", "substringBeforeLast", "trim", "predicate", "trimEnd", "trimStart", "kotlin-stdlib"}, xs="kotlin/text/StringsKt")
class StringsKt__StringsKt extends StringsKt__StringsJVMKt
{
  @NotNull
  public static final CharSequence trim(@NotNull CharSequence $receiver, @NotNull Function1<? super Character, Boolean> predicate)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");int startIndex = 0;
    int endIndex = $receiver.length() - 1;
    boolean startFound = false;
    
    while (startIndex <= endIndex) {
      int index = !startFound ? startIndex : endIndex;
      boolean match = ((Boolean)predicate.invoke(Character.valueOf($receiver.charAt(index)))).booleanValue();
      
      if (!startFound) {
        if (!match) {
          startFound = true;
        } else
          startIndex += 1;
      } else {
        if (!match) {
          break;
        }
        endIndex -= 1;
      }
    }
    
    return $receiver.subSequence(startIndex, endIndex + 1);
  }
  
  @NotNull
  public static final String trim(@NotNull String $receiver, @NotNull Function1<? super Character, Boolean> predicate)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");CharSequence $receiver$iv = (CharSequence)$receiver;
    







































































































































































































































































































































































































































































































































































































































    int $i$f$trim;
    







































































































































































































































































































































































































































































































































































































































    int startIndex$iv = 0;
    int endIndex$iv = $receiver$iv.length() - 1;
    boolean startFound$iv = false;
    
    while (startIndex$iv <= endIndex$iv) {
      int index$iv = !startFound$iv ? startIndex$iv : endIndex$iv;
      boolean match$iv = ((Boolean)predicate.invoke(Character.valueOf($receiver$iv.charAt(index$iv)))).booleanValue();
      
      if (!startFound$iv) {
        if (!match$iv) {
          startFound$iv = true;
        } else
          startIndex$iv += 1;
      } else {
        if (!match$iv) {
          break;
        }
        endIndex$iv -= 1;
      }
    }
    return 
    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv.subSequence(startIndex$iv, endIndex$iv + 1).toString();
  }
  
  @NotNull
  public static final CharSequence trimStart(@NotNull CharSequence $receiver, @NotNull Function1<? super Character, Boolean> predicate) {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");int i = 0; int index; for (int j = $receiver.length(); i < j; index++) {
      if (!((Boolean)predicate.invoke(Character.valueOf($receiver.charAt(index)))).booleanValue())
        return $receiver.subSequence(index, $receiver.length());
    }
    return (CharSequence)"";
  }
  
  @NotNull
  public static final String trimStart(@NotNull String $receiver, @NotNull Function1<? super Character, Boolean> predicate)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");CharSequence $receiver$iv = (CharSequence)$receiver;
    










































































































































































































































































































































































































































































































































































































































    int $i$f$trimStart;
    









































































































































































































































































































































































































































































































































































































































    int i = 0; int index$iv; for (int j = $receiver$iv.length(); i < j; index$iv++) {}
    return 
    






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      (!((Boolean)predicate.invoke(Character.valueOf($receiver$iv.charAt(index$iv)))).booleanValue() ? 
      $receiver$iv.subSequence(index$iv, $receiver$iv.length()) : 
      
      (CharSequence)"").toString();
  }
  
  @NotNull
  public static final CharSequence trimEnd(@NotNull CharSequence $receiver, @NotNull Function1<? super Character, Boolean> predicate) {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");int i = $receiver.length();i--; int index; for (int j = 0; i >= 0; index--) {
      if (!((Boolean)predicate.invoke(Character.valueOf($receiver.charAt(index)))).booleanValue())
        return $receiver.subSequence(0, index + 1);
    }
    return (CharSequence)"";
  }
  
  @NotNull
  public static final String trimEnd(@NotNull String $receiver, @NotNull Function1<? super Character, Boolean> predicate)
  {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(predicate, "predicate");CharSequence $receiver$iv = (CharSequence)$receiver;
    




































































































































































































































































































































































































































































































































































































































    int $i$f$trimEnd;
    



































































































































































































































































































































































































































































































































































































































    int i = $receiver$iv.length();i--; int index$iv; for (int j = 0; i >= 0; index$iv--) {}
    return 
    










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      (!((Boolean)predicate.invoke(Character.valueOf($receiver$iv.charAt(index$iv)))).booleanValue() ? 
      $receiver$iv.subSequence(0, index$iv + 1) : 
      
      (CharSequence)"").toString();
  }
  

















  @InlineOnly
  private static final String trim(@NotNull String $receiver)
  {
    ;
    
















    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.trim((CharSequence)$receiver).toString();
  }
  


  @InlineOnly
  private static final String trimStart(@NotNull String $receiver)
  {
    ;
    

    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.trimStart((CharSequence)$receiver).toString();
  }
  


  @InlineOnly
  private static final String trimEnd(@NotNull String $receiver)
  {
    ;
    

    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.trimEnd((CharSequence)$receiver).toString();
  }
  







  @NotNull
  public static final CharSequence padStart(@NotNull CharSequence $receiver, int length, char padChar)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0"); if (length < 0)
      throw ((Throwable)new IllegalArgumentException("Desired length " + length + " is less than zero."));
    if (length <= $receiver.length()) {
      return $receiver.subSequence(0, $receiver.length());
    }
    StringBuilder sb = new StringBuilder(length);
    int i = 1;int j = length - $receiver.length(); int i; for (i > j;; i++) {
      sb.append(padChar);
      if (i == j) break;
    }
    sb.append($receiver);
    return (CharSequence)sb;
  }
  







  @NotNull
  public static final String padStart(@NotNull String $receiver, int length, char padChar)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return StringsKt.padStart((CharSequence)$receiver, length, padChar).toString();
  }
  







  @NotNull
  public static final CharSequence padEnd(@NotNull CharSequence $receiver, int length, char padChar)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0"); if (length < 0)
      throw ((Throwable)new IllegalArgumentException("Desired length " + length + " is less than zero."));
    if (length <= $receiver.length()) {
      return $receiver.subSequence(0, $receiver.length());
    }
    StringBuilder sb = new StringBuilder(length);
    sb.append($receiver);
    int i = 1;int j = length - $receiver.length(); int i; for (i > j;; i++) {
      sb.append(padChar);
      if (i == j) break;
    }
    return (CharSequence)sb;
  }
  







  @NotNull
  public static final String padEnd(@NotNull String $receiver, int length, char padChar)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return StringsKt.padEnd((CharSequence)$receiver, length, padChar).toString();
  }
  


  @InlineOnly
  private static final boolean isNullOrEmpty(@org.jetbrains.annotations.Nullable CharSequence $receiver)
  {
    ;
    

    return ($receiver == null) || ($receiver.length() == 0);
  }
  
  @InlineOnly
  private static final boolean isEmpty(@NotNull CharSequence $receiver)
  {
    ;
    return $receiver.length() == 0;
  }
  
  @InlineOnly
  private static final boolean isNotEmpty(@NotNull CharSequence $receiver) {
    ;
    return $receiver.length() > 0;
  }
  


  @InlineOnly
  private static final boolean isNotBlank(@NotNull CharSequence $receiver)
  {
    ;
    
    return !StringsKt.isBlank($receiver);
  }
  


  @InlineOnly
  private static final boolean isNullOrBlank(@org.jetbrains.annotations.Nullable CharSequence $receiver)
  {
    ;
    

    return ($receiver == null) || (StringsKt.isBlank($receiver));
  }
  
  @NotNull
  public static final kotlin.collections.CharIterator iterator(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");(kotlin.collections.CharIterator)new kotlin.collections.CharIterator() {
      private int index;
      
      public char nextChar() { int i = tmp9_6;return $this_iterator.charAt(i); }
      
      public boolean hasNext() { return index < $this_iterator.length(); }
    };
  }
  




  @kotlin.SinceKotlin(version="1.3")
  @InlineOnly
  private static final <C extends CharSequence,  extends R, R> R ifEmpty(C $receiver, kotlin.jvm.functions.Function0<? extends R> defaultValue)
  {
    ;
    


    CharSequence localCharSequence = $receiver;return (localCharSequence.length() == 0 ? 1 : 0) != 0 ? defaultValue.invoke() : $receiver;
  }
  


  @kotlin.SinceKotlin(version="1.3")
  @InlineOnly
  private static final <C extends CharSequence,  extends R, R> R ifBlank(C $receiver, kotlin.jvm.functions.Function0<? extends R> defaultValue)
  {
    ;
    
    return StringsKt.isBlank($receiver) ? defaultValue.invoke() : $receiver;
  }
  
  @NotNull
  public static final IntRange getIndices(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");int i = 0;return new IntRange(i, $receiver.length() - 1);
  }
  

  public static final int getLastIndex(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return $receiver.length() - 1;
  }
  








  @NotNull
  public static final String substring(@NotNull String $receiver, @NotNull IntRange range)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(range, "range");String str = $receiver;int i = range.getStart().intValue();int j = range.getEndInclusive().intValue() + 1; String tmp40_37 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp40_37, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp40_37;
  }
  
  @NotNull
  public static final CharSequence subSequence(@NotNull CharSequence $receiver, @NotNull IntRange range) {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(range, "range");return $receiver.subSequence(range.getStart().intValue(), range.getEndInclusive().intValue() + 1);
  }
  
  /**
   * @deprecated
   */
  @kotlin.Deprecated(message="Use parameters named startIndex and endIndex.", replaceWith=@kotlin.ReplaceWith(imports={}, expression="subSequence(startIndex = start, endIndex = end)"))
  @InlineOnly
  private static final CharSequence subSequence(@NotNull String $receiver, int start, int end)
  {
    ;
    return $receiver.subSequence(start, end);
  }
  

  @InlineOnly
  private static final String substring(@NotNull CharSequence $receiver, int startIndex, int endIndex)
  {
    ;
    
    return $receiver.subSequence(startIndex, endIndex).toString();
  }
  
  @NotNull
  public static final String substring(@NotNull CharSequence $receiver, @NotNull IntRange range) {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(range, "range");return $receiver.subSequence(range.getStart().intValue(), range.getEndInclusive().intValue() + 1).toString();
  }
  

  @NotNull
  public static final String substringBefore(@NotNull String $receiver, char delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0; String tmp50_47 = str.substring(i, index);Intrinsics.checkExpressionValueIsNotNull(tmp50_47, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp50_47;
  }
  


  @NotNull
  public static final String substringBefore(@NotNull String $receiver, @NotNull String delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0; String tmp57_54 = str.substring(i, index);Intrinsics.checkExpressionValueIsNotNull(tmp57_54, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp57_54;
  }
  


  @NotNull
  public static final String substringAfter(@NotNull String $receiver, char delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + 1;int j = $receiver.length(); String tmp59_56 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp59_56, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp59_56;
  }
  


  @NotNull
  public static final String substringAfter(@NotNull String $receiver, @NotNull String delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + delimiter.length();int j = $receiver.length(); String tmp69_66 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp69_66, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp69_66;
  }
  


  @NotNull
  public static final String substringBeforeLast(@NotNull String $receiver, char delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0; String tmp50_47 = str.substring(i, index);Intrinsics.checkExpressionValueIsNotNull(tmp50_47, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp50_47;
  }
  


  @NotNull
  public static final String substringBeforeLast(@NotNull String $receiver, @NotNull String delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0; String tmp57_54 = str.substring(i, index);Intrinsics.checkExpressionValueIsNotNull(tmp57_54, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp57_54;
  }
  


  @NotNull
  public static final String substringAfterLast(@NotNull String $receiver, char delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + 1;int j = $receiver.length(); String tmp59_56 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp59_56, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp59_56;
  }
  


  @NotNull
  public static final String substringAfterLast(@NotNull String $receiver, @NotNull String delimiter, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + delimiter.length();int j = $receiver.length(); String tmp69_66 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp69_66, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp69_66;
  }
  




  @NotNull
  public static final CharSequence replaceRange(@NotNull CharSequence $receiver, int startIndex, int endIndex, @NotNull CharSequence replacement)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(replacement, "replacement"); if (endIndex < startIndex)
      throw ((Throwable)new IndexOutOfBoundsException("End index (" + endIndex + ") is less than start index (" + startIndex + ")."));
    StringBuilder sb = new StringBuilder();
    sb.append($receiver, 0, startIndex);
    sb.append(replacement);
    sb.append($receiver, endIndex, $receiver.length());
    return (CharSequence)sb;
  }
  


  @InlineOnly
  private static final String replaceRange(@NotNull String $receiver, int startIndex, int endIndex, CharSequence replacement)
  {
    ;
    
    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.replaceRange((CharSequence)$receiver, startIndex, endIndex, replacement).toString();
  }
  



  @NotNull
  public static final CharSequence replaceRange(@NotNull CharSequence $receiver, @NotNull IntRange range, @NotNull CharSequence replacement)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(range, "range");Intrinsics.checkParameterIsNotNull(replacement, "replacement");return StringsKt.replaceRange($receiver, range.getStart().intValue(), range.getEndInclusive().intValue() + 1, replacement);
  }
  

  @InlineOnly
  private static final String replaceRange(@NotNull String $receiver, IntRange range, CharSequence replacement)
  {
    ;
    
    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.replaceRange((CharSequence)$receiver, range, replacement).toString();
  }
  





  @NotNull
  public static final CharSequence removeRange(@NotNull CharSequence $receiver, int startIndex, int endIndex)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0"); if (endIndex < startIndex) {
      throw ((Throwable)new IndexOutOfBoundsException("End index (" + endIndex + ") is less than start index (" + startIndex + ")."));
    }
    if (endIndex == startIndex) {
      return $receiver.subSequence(0, $receiver.length());
    }
    StringBuilder sb = new StringBuilder($receiver.length() - (endIndex - startIndex));
    sb.append($receiver, 0, startIndex);
    sb.append($receiver, endIndex, $receiver.length());
    return (CharSequence)sb;
  }
  



  @InlineOnly
  private static final String removeRange(@NotNull String $receiver, int startIndex, int endIndex)
  {
    ;
    

    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.removeRange((CharSequence)$receiver, startIndex, endIndex).toString();
  }
  

  @NotNull
  public static final CharSequence removeRange(@NotNull CharSequence $receiver, @NotNull IntRange range)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(range, "range");return StringsKt.removeRange($receiver, range.getStart().intValue(), range.getEndInclusive().intValue() + 1);
  }
  

  @InlineOnly
  private static final String removeRange(@NotNull String $receiver, IntRange range)
  {
    ;
    
    if ($receiver == null) throw new kotlin.TypeCastException("null cannot be cast to non-null type kotlin.CharSequence"); return StringsKt.removeRange((CharSequence)$receiver, range).toString();
  }
  

  @NotNull
  public static final CharSequence removePrefix(@NotNull CharSequence $receiver, @NotNull CharSequence prefix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix"); if (StringsKt.startsWith$default($receiver, prefix, false, 2, null)) {
      return $receiver.subSequence(prefix.length(), $receiver.length());
    }
    return $receiver.subSequence(0, $receiver.length());
  }
  


  @NotNull
  public static final String removePrefix(@NotNull String $receiver, @NotNull CharSequence prefix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix"); if (StringsKt.startsWith$default((CharSequence)$receiver, prefix, false, 2, null)) {
      String str = $receiver;int i = prefix.length(); String tmp41_38 = str.substring(i);Intrinsics.checkExpressionValueIsNotNull(tmp41_38, "(this as java.lang.String).substring(startIndex)");return tmp41_38;
    }
    return $receiver;
  }
  


  @NotNull
  public static final CharSequence removeSuffix(@NotNull CharSequence $receiver, @NotNull CharSequence suffix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(suffix, "suffix"); if (StringsKt.endsWith$default($receiver, suffix, false, 2, null)) {
      return $receiver.subSequence(0, $receiver.length() - suffix.length());
    }
    return $receiver.subSequence(0, $receiver.length());
  }
  


  @NotNull
  public static final String removeSuffix(@NotNull String $receiver, @NotNull CharSequence suffix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(suffix, "suffix"); if (StringsKt.endsWith$default((CharSequence)$receiver, suffix, false, 2, null)) {
      String str = $receiver;int i = 0;int j = $receiver.length() - suffix.length(); String tmp51_48 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp51_48, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp51_48;
    }
    return $receiver;
  }
  



  @NotNull
  public static final CharSequence removeSurrounding(@NotNull CharSequence $receiver, @NotNull CharSequence prefix, @NotNull CharSequence suffix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix");Intrinsics.checkParameterIsNotNull(suffix, "suffix"); if (($receiver.length() >= prefix.length() + suffix.length()) && (StringsKt.startsWith$default($receiver, prefix, false, 2, null)) && (StringsKt.endsWith$default($receiver, suffix, false, 2, null))) {
      return $receiver.subSequence(prefix.length(), $receiver.length() - suffix.length());
    }
    return $receiver.subSequence(0, $receiver.length());
  }
  



  @NotNull
  public static final String removeSurrounding(@NotNull String $receiver, @NotNull CharSequence prefix, @NotNull CharSequence suffix)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix");Intrinsics.checkParameterIsNotNull(suffix, "suffix"); if (($receiver.length() >= prefix.length() + suffix.length()) && (StringsKt.startsWith$default((CharSequence)$receiver, prefix, false, 2, null)) && (StringsKt.endsWith$default((CharSequence)$receiver, suffix, false, 2, null))) {
      String str = $receiver;int i = prefix.length();int j = $receiver.length() - suffix.length(); String tmp99_96 = str.substring(i, j);Intrinsics.checkExpressionValueIsNotNull(tmp99_96, "(this as java.lang.Strin…ing(startIndex, endIndex)");return tmp99_96;
    }
    return $receiver;
  }
  


  @NotNull
  public static final CharSequence removeSurrounding(@NotNull CharSequence $receiver, @NotNull CharSequence delimiter)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");return StringsKt.removeSurrounding($receiver, delimiter, delimiter);
  }
  

  @NotNull
  public static final String removeSurrounding(@NotNull String $receiver, @NotNull CharSequence delimiter)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");return StringsKt.removeSurrounding($receiver, delimiter, delimiter);
  }
  

  @NotNull
  public static final String replaceBefore(@NotNull String $receiver, char delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0;return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, index, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceBefore(@NotNull String $receiver, @NotNull String delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0;return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, index, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceAfter(@NotNull String $receiver, char delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + 1;int j = $receiver.length();return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, j, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceAfter(@NotNull String $receiver, @NotNull String delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.indexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + delimiter.length();int j = $receiver.length();return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, j, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceAfterLast(@NotNull String $receiver, @NotNull String delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + delimiter.length();int j = $receiver.length();return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, j, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceAfterLast(@NotNull String $receiver, char delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = index + 1;int j = $receiver.length();return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, j, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceBeforeLast(@NotNull String $receiver, char delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0;return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, index, (CharSequence)replacement).toString();
  }
  


  @NotNull
  public static final String replaceBeforeLast(@NotNull String $receiver, @NotNull String delimiter, @NotNull String replacement, @NotNull String missingDelimiterValue)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiter, "delimiter");Intrinsics.checkParameterIsNotNull(replacement, "replacement");Intrinsics.checkParameterIsNotNull(missingDelimiterValue, "missingDelimiterValue");int index = StringsKt.lastIndexOf$default((CharSequence)$receiver, delimiter, 0, false, 6, null);
    String str = $receiver;int i = 0;return index == -1 ? missingDelimiterValue : StringsKt.replaceRange((CharSequence)str, i, index, (CharSequence)replacement).toString();
  }
  




  @InlineOnly
  private static final String replace(@NotNull CharSequence $receiver, Regex regex, String replacement)
  {
    ;
    



    return regex.replace($receiver, replacement);
  }
  

  @InlineOnly
  private static final String replace(@NotNull CharSequence $receiver, Regex regex, Function1<? super MatchResult, ? extends CharSequence> transform)
  {
    ;
    
    return regex.replace($receiver, transform);
  }
  

  @InlineOnly
  private static final String replaceFirst(@NotNull CharSequence $receiver, Regex regex, String replacement)
  {
    ;
    return regex.replaceFirst($receiver, replacement);
  }
  
  @InlineOnly
  private static final boolean matches(@NotNull CharSequence $receiver, Regex regex)
  {
    ;
    return regex.matches($receiver);
  }
  


  public static final boolean regionMatchesImpl(@NotNull CharSequence $receiver, int thisOffset, @NotNull CharSequence other, int otherOffset, int length, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(other, "other"); if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > $receiver.length() - length) || (otherOffset > other.length() - length)) {
      return false;
    }
    
    int i = 0; int index; for (int j = length; i < j; index++) {
      if (!CharsKt.equals($receiver.charAt(thisOffset + index), other.charAt(otherOffset + index), ignoreCase))
        return false;
    }
    return true;
  }
  


  public static final boolean startsWith(@NotNull CharSequence $receiver, char char, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return ($receiver.length() > 0) && (CharsKt.equals($receiver.charAt(0), char, ignoreCase));
  }
  

  public static final boolean endsWith(@NotNull CharSequence $receiver, char char, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return ($receiver.length() > 0) && (CharsKt.equals($receiver.charAt(StringsKt.getLastIndex($receiver)), char, ignoreCase));
  }
  

  public static final boolean startsWith(@NotNull CharSequence $receiver, @NotNull CharSequence prefix, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix"); if ((!ignoreCase) && (($receiver instanceof String)) && ((prefix instanceof String))) {
      return StringsKt.startsWith$default((String)$receiver, (String)prefix, false, 2, null);
    }
    return StringsKt.regionMatchesImpl($receiver, 0, prefix, 0, prefix.length(), ignoreCase);
  }
  


  public static final boolean startsWith(@NotNull CharSequence $receiver, @NotNull CharSequence prefix, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(prefix, "prefix"); if ((!ignoreCase) && (($receiver instanceof String)) && ((prefix instanceof String))) {
      return StringsKt.startsWith$default((String)$receiver, (String)prefix, startIndex, false, 4, null);
    }
    return StringsKt.regionMatchesImpl($receiver, startIndex, prefix, 0, prefix.length(), ignoreCase);
  }
  


  public static final boolean endsWith(@NotNull CharSequence $receiver, @NotNull CharSequence suffix, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(suffix, "suffix"); if ((!ignoreCase) && (($receiver instanceof String)) && ((suffix instanceof String))) {
      return StringsKt.endsWith$default((String)$receiver, (String)suffix, false, 2, null);
    }
    return StringsKt.regionMatchesImpl($receiver, $receiver.length() - suffix.length(), suffix, 0, suffix.length(), ignoreCase);
  }
  









  @NotNull
  public static final String commonPrefixWith(@NotNull CharSequence $receiver, @NotNull CharSequence other, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(other, "other");int i = $receiver.length();int j = other.length();int shortestLength = Math.min(i, j);
    
    int i = 0;
    while ((i < shortestLength) && (CharsKt.equals($receiver.charAt(i), other.charAt(i), ignoreCase))) {
      i++;
    }
    if ((StringsKt.hasSurrogatePairAt($receiver, i - 1)) || (StringsKt.hasSurrogatePairAt(other, i - 1))) {
      i--;
    }
    return $receiver.subSequence(0, i).toString();
  }
  






  @NotNull
  public static final String commonSuffixWith(@NotNull CharSequence $receiver, @NotNull CharSequence other, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(other, "other");int thisLength = $receiver.length();
    int otherLength = other.length();
    int shortestLength = Math.min(thisLength, otherLength);
    
    int i = 0;
    while ((i < shortestLength) && (CharsKt.equals($receiver.charAt(thisLength - i - 1), other.charAt(otherLength - i - 1), ignoreCase))) {
      i++;
    }
    if ((StringsKt.hasSurrogatePairAt($receiver, thisLength - i - 1)) || (StringsKt.hasSurrogatePairAt(other, otherLength - i - 1))) {
      i--;
    }
    return $receiver.subSequence(thisLength - i, thisLength).toString();
  }
  










  public static final int indexOfAny(@NotNull CharSequence $receiver, @NotNull char[] chars, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars"); if ((!ignoreCase) && (chars.length == 1) && (($receiver instanceof String))) {
      char = kotlin.collections.ArraysKt.single(chars);
      String str = (String)$receiver;return str.indexOf(char, startIndex);
    }
    
    char char = kotlin.ranges.RangesKt.coerceAtLeast(startIndex, 0);char c1 = StringsKt.getLastIndex($receiver); int index; for (char > c1;; index++) {
      char charAtIndex = $receiver.charAt(index);
      char[] $receiver$iv = chars;
      















































































































































      int $i$f$any;
      















































































































































      char it;
      















































































































































      int $i$a$1$any;
      














































































































































      for (char element$iv : $receiver$iv) it = element$iv;
      if ((CharsKt.equals(it, charAtIndex, ignoreCase) ? 1 : 0) != 0) {
        return index;
      }
      if (index == c1) {
        break;
      }
    }
    
    return -1;
  }
  








  public static final int lastIndexOfAny(@NotNull CharSequence $receiver, @NotNull char[] chars, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars"); if ((!ignoreCase) && (chars.length == 1) && (($receiver instanceof String))) {
      char = kotlin.collections.ArraysKt.single(chars);
      String str = (String)$receiver;return str.lastIndexOf(char, startIndex);
    }
    

    char char = kotlin.ranges.RangesKt.coerceAtMost(startIndex, StringsKt.getLastIndex($receiver)); int index; for (int i = 0; char >= 0; index--) {
      char charAtIndex = $receiver.charAt(index);
      char[] $receiver$iv = chars;
      










































































































































      int $i$f$any;
      









































































































































      char it;
      









































































































































      int $i$a$1$any;
      









































































































































      for (char element$iv : $receiver$iv) it = element$iv;
      if ((CharsKt.equals(it, charAtIndex, ignoreCase) ? 1 : 0) != 0) {
        return index;
      }
    }
    return -1;
  }
  

























































  @org.jetbrains.annotations.Nullable
  public static final kotlin.Pair<Integer, String> findAnyOf(@NotNull CharSequence $receiver, @NotNull Collection<String> strings, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(strings, "strings");return findAnyOf$StringsKt__StringsKt($receiver, strings, startIndex, ignoreCase, false);
  }
  









  @org.jetbrains.annotations.Nullable
  public static final kotlin.Pair<Integer, String> findLastAnyOf(@NotNull CharSequence $receiver, @NotNull Collection<String> strings, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(strings, "strings");return findAnyOf$StringsKt__StringsKt($receiver, strings, startIndex, ignoreCase, true);
  }
  




































  public static final int indexOf(@NotNull CharSequence $receiver, char char, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");
    

    String str = (String)$receiver;return (ignoreCase) || (!($receiver instanceof String)) ? StringsKt.indexOfAny($receiver, new char[] { char }, startIndex, ignoreCase) : str.indexOf(char, startIndex);
  }
  






  public static final int indexOf(@NotNull CharSequence $receiver, @NotNull String string, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(string, "string");
    

    String str = (String)$receiver;return (ignoreCase) || (!($receiver instanceof String)) ? indexOf$StringsKt__StringsKt$default($receiver, (CharSequence)string, startIndex, $receiver.length(), ignoreCase, false, 16, null) : str.indexOf(string, startIndex);
  }
  







  public static final int lastIndexOf(@NotNull CharSequence $receiver, char char, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");
    

    String str = (String)$receiver;return (ignoreCase) || (!($receiver instanceof String)) ? StringsKt.lastIndexOfAny($receiver, new char[] { char }, startIndex, ignoreCase) : str.lastIndexOf(char, startIndex);
  }
  







  public static final int lastIndexOf(@NotNull CharSequence $receiver, @NotNull String string, int startIndex, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(string, "string");
    

    String str = (String)$receiver;return (ignoreCase) || (!($receiver instanceof String)) ? indexOf$StringsKt__StringsKt($receiver, (CharSequence)string, startIndex, 0, ignoreCase, true) : str.lastIndexOf(string, startIndex);
  }
  





  public static final boolean contains(@NotNull CharSequence $receiver, @NotNull CharSequence other, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(other, "other");
    

    return StringsKt.indexOf$default($receiver, (String)other, 0, ignoreCase, 2, null) >= 0;
  }
  






  public static final boolean contains(@NotNull CharSequence $receiver, char char, boolean ignoreCase)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return StringsKt.indexOf$default($receiver, char, 0, ignoreCase, 2, null) >= 0;
  }
  
  @InlineOnly
  private static final boolean contains(@NotNull CharSequence $receiver, Regex regex) {
    ;
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return regex.containsMatchIn($receiver);
  }
  






































































  private static final kotlin.sequences.Sequence<IntRange> rangesDelimitedBy$StringsKt__StringsKt(@NotNull CharSequence $receiver, char[] delimiters, int startIndex, final boolean ignoreCase, int limit)
  {
    int i = limit >= 0 ? 1 : 0; if (i == 0) { int $i$a$1$require; String str = "Limit must be non-negative, but was " + limit + '.';throw ((Throwable)new IllegalArgumentException(str.toString()));
    }
    (kotlin.sequences.Sequence)new DelimitedRangesSequence($receiver, startIndex, limit, (kotlin.jvm.functions.Function2)new kotlin.jvm.internal.Lambda(delimiters) { @org.jetbrains.annotations.Nullable
      public final kotlin.Pair<Integer, Integer> invoke(@NotNull CharSequence $receiver, int currentIndex) { Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");int i = StringsKt.indexOfAny($receiver, $delimiters, currentIndex, ignoreCase);int it = i; int $i$a$1$let; return it < 0 ? null : kotlin.TuplesKt.to(Integer.valueOf(it), Integer.valueOf(1));
      }
    });
  }
  













  private static final kotlin.sequences.Sequence<IntRange> rangesDelimitedBy$StringsKt__StringsKt(@NotNull CharSequence $receiver, String[] delimiters, int startIndex, final boolean ignoreCase, int limit)
  {
    int i = limit >= 0 ? 1 : 0; if (i == 0) { int $i$a$3$require; String str = "Limit must be non-negative, but was " + limit + '.';throw ((Throwable)new IllegalArgumentException(str.toString())); }
    java.util.List delimitersList = kotlin.collections.ArraysKt.asList(delimiters);
    
    (kotlin.sequences.Sequence)new DelimitedRangesSequence($receiver, startIndex, limit, (kotlin.jvm.functions.Function2)new kotlin.jvm.internal.Lambda(delimitersList)
    {
      /* Error */
      @org.jetbrains.annotations.Nullable
      public final kotlin.Pair<Integer, Integer> invoke(@NotNull CharSequence $receiver, int currentIndex)
      {
        // Byte code:
        //   0: aload_1
        //   1: ldc 24
        //   3: invokestatic 30	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
        //   6: aload_1
        //   7: aload_0
        //   8: getfield 34	kotlin/text/StringsKt__StringsKt$rangesDelimitedBy$4:$delimitersList	Ljava/util/List;
        //   11: checkcast 36	java/util/Collection
        //   14: iload_2
        //   15: aload_0
        //   16: getfield 40	kotlin/text/StringsKt__StringsKt$rangesDelimitedBy$4:$ignoreCase	Z
        //   19: iconst_0
        //   20: invokestatic 46	kotlin/text/StringsKt__StringsKt:access$findAnyOf	(Ljava/lang/CharSequence;Ljava/util/Collection;IZZ)Lkotlin/Pair;
        //   23: dup
        //   24: ifnull +32 -> 56
        //   27: astore_3
        //   28: aload_3
        //   29: astore 4
        //   31: aload 4
        //   33: invokevirtual 52	kotlin/Pair:getFirst	()Ljava/lang/Object;
        //   36: aload 4
        //   38: invokevirtual 55	kotlin/Pair:getSecond	()Ljava/lang/Object;
        //   41: checkcast 57	java/lang/String
        //   44: invokevirtual 60	java/lang/String:length	()I
        //   47: invokestatic 66	java/lang/Integer:valueOf	(I)Ljava/lang/Integer;
        //   50: invokestatic 72	kotlin/TuplesKt:to	(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
        //   53: goto +5 -> 58
        //   56: pop
        //   57: aconst_null
        //   58: areturn
        // Line number table:
        //   Java source line #1157	-> byte code offset #6
        //   Java source line #1157	-> byte code offset #31
        //   Java source line #1157	-> byte code offset #53
        //   Java source line #1157	-> byte code offset #58
        // Local variable table:
        //   start	length	slot	name	signature
        //   0	59	0	this	4
        //   0	59	1	$receiver	CharSequence
        //   0	59	2	currentIndex	int
        //   31	22	4	it	kotlin.Pair
        //   31	22	5	$i$a$1$let	int
      }
    });
  }
  
  @NotNull
  public static final kotlin.sequences.Sequence<String> splitToSequence(@NotNull CharSequence $receiver, @NotNull String[] delimiters, boolean ignoreCase, int limit)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiters, "delimiters");kotlin.sequences.SequencesKt.map(rangesDelimitedBy$StringsKt__StringsKt$default($receiver, delimiters, 0, ignoreCase, limit, 2, null), (Function1)new kotlin.jvm.internal.Lambda($receiver) { @NotNull
      public final String invoke(@NotNull IntRange it) { Intrinsics.checkParameterIsNotNull(it, "it");return StringsKt.substring($this_splitToSequence, it);
      }
    });
  }
  
























  @NotNull
  public static final kotlin.sequences.Sequence<String> splitToSequence(@NotNull CharSequence $receiver, @NotNull char[] delimiters, boolean ignoreCase, int limit)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiters, "delimiters");kotlin.sequences.SequencesKt.map(rangesDelimitedBy$StringsKt__StringsKt$default($receiver, delimiters, 0, ignoreCase, limit, 2, null), (Function1)new kotlin.jvm.internal.Lambda($receiver) { @NotNull
      public final String invoke(@NotNull IntRange it) { Intrinsics.checkParameterIsNotNull(it, "it");return StringsKt.substring($this_splitToSequence, it);
      }
    });
  }
  



















  private static final java.util.List<String> split$StringsKt__StringsKt(@NotNull CharSequence $receiver, String delimiter, boolean ignoreCase, int limit)
  {
    int i = limit >= 0 ? 1 : 0; if (i == 0) { int $i$a$3$require; String str1 = "Limit must be non-negative, but was " + limit + '.';throw ((Throwable)new IllegalArgumentException(str1.toString()));
    }
    int currentOffset = 0;
    int nextIndex = StringsKt.indexOf($receiver, delimiter, currentOffset, ignoreCase);
    if ((nextIndex == -1) || (limit == 1)) {
      return kotlin.collections.CollectionsKt.listOf($receiver.toString());
    }
    
    boolean isLimited = limit > 0;
    java.util.ArrayList result = new java.util.ArrayList(isLimited ? kotlin.ranges.RangesKt.coerceAtMost(limit, 10) : 10);
    do {
      localCharSequence = $receiver;localArrayList1 = result;str2 = localCharSequence.subSequence(currentOffset, nextIndex).toString();localArrayList1.add(str2);
      currentOffset = nextIndex + delimiter.length();
      
      if ((isLimited) && (result.size() == limit - 1)) break;
      nextIndex = StringsKt.indexOf($receiver, delimiter, currentOffset, ignoreCase);
    } while (nextIndex != -1);
    
    CharSequence localCharSequence = $receiver;int j = $receiver.length();java.util.ArrayList localArrayList1 = result;String str2 = localCharSequence.subSequence(currentOffset, j).toString();localArrayList1.add(str2);
    return (java.util.List)result;
  }
  


  @InlineOnly
  private static final java.util.List<String> split(@NotNull CharSequence $receiver, Regex regex, int limit)
  {
    ;
    
    return regex.split($receiver, limit);
  }
  

  @NotNull
  public static final kotlin.sequences.Sequence<String> lineSequence(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return StringsKt.splitToSequence$default($receiver, new String[] { "\r\n", "\n", "\r" }, false, 0, 6, null);
  }
  

  @NotNull
  public static final java.util.List<String> lines(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");return kotlin.sequences.SequencesKt.toList(StringsKt.lineSequence($receiver));
  }
  
  @NotNull
  public static final CharSequence trim(@NotNull CharSequence $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");CharSequence $receiver$iv = $receiver;
    




































































































































































































































































































































































































































































































































































































































    int $i$f$trim;
    



































































































































































































































































































































































































































































































































































































































    int startIndex$iv = 0;
    int endIndex$iv = $receiver$iv.length() - 1;
    boolean startFound$iv = false;
    
    while (startIndex$iv <= endIndex$iv) {
      int index$iv = !startFound$iv ? startIndex$iv : endIndex$iv;
      char it = $receiver$iv.charAt(index$iv);
      int $i$a$1$trim;
      boolean match$iv = kotlin.collections.ArraysKt.contains(chars, it);
      

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      if (!startFound$iv) {
        if (!match$iv) {
          startFound$iv = true;
        } else
          startIndex$iv += 1;
      } else {
        if (!match$iv) {
          break;
        }
        endIndex$iv -= 1;
      }
    }
    return 
    






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv.subSequence(startIndex$iv, endIndex$iv + 1);
  }
  
  @NotNull
  public static final String trim(@NotNull String $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");String $receiver$iv = $receiver;
    












































































































































































































































































































































































































































































































































































































































    int $i$f$trim;
    












































































































































































































































































































































































































































































































































































































































    CharSequence $receiver$iv$iv = (CharSequence)$receiver$iv;
    int $i$f$trim; int startIndex$iv$iv = 0;
    int endIndex$iv$iv = $receiver$iv$iv.length() - 1;
    boolean startFound$iv$iv = false;
    
    while (startIndex$iv$iv <= endIndex$iv$iv) {
      int index$iv$iv = !startFound$iv$iv ? startIndex$iv$iv : endIndex$iv$iv;
      char it = $receiver$iv$iv.charAt(index$iv$iv);
      int $i$a$2$trim;
      boolean match$iv$iv = kotlin.collections.ArraysKt.contains(chars, it);
      



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      if (!startFound$iv$iv) {
        if (!match$iv$iv) {
          startFound$iv$iv = true;
        } else
          startIndex$iv$iv += 1;
      } else {
        if (!match$iv$iv) {
          break;
        }
        endIndex$iv$iv -= 1;
      }
    }
    return 
    
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv$iv.subSequence(startIndex$iv$iv, endIndex$iv$iv + 1).toString();
  }
  
  @NotNull
  public static final CharSequence trimStart(@NotNull CharSequence $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");CharSequence $receiver$iv = $receiver;
    





















































































































































































































































































































































































































































































































































































































































    int $i$f$trimStart;
    





















































































































































































































































































































































































































































































































































































































































    int i = 0; int index$iv; char it; int $i$a$1$trimStart; for (int j = $receiver$iv.length(); i < j; index$iv++) {
      it = $receiver$iv.charAt(index$iv);
    }
    return !kotlin.collections.ArraysKt.contains(chars, it) ? 
    














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv.subSequence(index$iv, $receiver$iv.length()) : 
      
      (CharSequence)"";
  }
  
  @NotNull
  public static final String trimStart(@NotNull String $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");String $receiver$iv = $receiver;
    





















































































































































































































































































































































































































































































































































































































































    int $i$f$trimStart;
    





















































































































































































































































































































































































































































































































































































































































    CharSequence $receiver$iv$iv = (CharSequence)$receiver$iv;
    int $i$f$trimStart; int i = 0; int index$iv$iv; char it; int $i$a$2$trimStart; for (int j = $receiver$iv$iv.length(); i < j; index$iv$iv++) {
      it = $receiver$iv$iv.charAt(index$iv$iv);
    }
    return 
    












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      (!kotlin.collections.ArraysKt.contains(chars, it) ? 
      

      $receiver$iv$iv.subSequence(index$iv$iv, $receiver$iv$iv.length()) : 
      
      (CharSequence)"").toString();
  }
  
  @NotNull
  public static final CharSequence trimEnd(@NotNull CharSequence $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");CharSequence $receiver$iv = $receiver;
    






















































































































































































































































































































































































































































































































































































































































    int $i$f$trimEnd;
    





















































































































































































































































































































































































































































































































































































































































    int i = $receiver$iv.length();i--; int index$iv; char it; int $i$a$1$trimEnd; for (int j = 0; i >= 0; index$iv--) {
      it = $receiver$iv.charAt(index$iv);
    }
    return !kotlin.collections.ArraysKt.contains(chars, it) ? 
    















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv.subSequence(0, index$iv + 1) : 
      
      (CharSequence)"";
  }
  
  @NotNull
  public static final String trimEnd(@NotNull String $receiver, @NotNull char... chars)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(chars, "chars");String $receiver$iv = $receiver;
    






















































































































































































































































































































































































































































































































































































































































    int $i$f$trimEnd;
    





















































































































































































































































































































































































































































































































































































































































    CharSequence $receiver$iv$iv = (CharSequence)$receiver$iv;
    int $i$f$trimEnd; int i = $receiver$iv$iv.length();i--; int index$iv$iv; char it; int $i$a$2$trimEnd; for (int j = 0; i >= 0; index$iv$iv--) {
      it = $receiver$iv$iv.charAt(index$iv$iv);
    }
    return 
    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      (!kotlin.collections.ArraysKt.contains(chars, it) ? 
      

      $receiver$iv$iv.subSequence(0, index$iv$iv + 1) : 
      
      (CharSequence)"").toString();
  }
  
  @NotNull
  public static final CharSequence trim(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");CharSequence $receiver$iv = $receiver;
    






















































































































































































































































































































































































































































































































































































































































    int $i$f$trim;
    






















































































































































































































































































































































































































































































































































































































































    int startIndex$iv = 0;
    int endIndex$iv = $receiver$iv.length() - 1;
    boolean startFound$iv = false;
    
    while (startIndex$iv <= endIndex$iv) {
      int index$iv = !startFound$iv ? startIndex$iv : endIndex$iv;
      char p1 = $receiver$iv.charAt(index$iv);
      int $i$a$3$unknown;
      boolean match$iv = CharsKt.isWhitespace(
      




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































        p1);
      
      if (!startFound$iv) {
        if (!match$iv) {
          startFound$iv = true;
        } else
          startIndex$iv += 1;
      } else {
        if (!match$iv) {
          break;
        }
        endIndex$iv -= 1;
      }
    }
    return 
    



































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      $receiver$iv.subSequence(startIndex$iv, endIndex$iv + 1);
  }
  
  @NotNull
  public static final CharSequence trimStart(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");CharSequence $receiver$iv = $receiver;
    




























































































































































































































































































































































































































































































































































































































































    int $i$f$trimStart;
    



























































































































































































































































































































































































































































































































































































































































    int i = 0; int index$iv; char p1; int $i$a$3$unknown; for (int j = $receiver$iv.length(); i < j; index$iv++) {
      p1 = $receiver$iv.charAt(index$iv);
    }
    return !CharsKt.isWhitespace(
    


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      p1) ? 
      $receiver$iv.subSequence(index$iv, $receiver$iv.length()) : 
      
      (CharSequence)"";
  }
  
  @NotNull
  public static final CharSequence trimEnd(@NotNull CharSequence $receiver)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");CharSequence $receiver$iv = $receiver;
    

























































































































































































































































































































































































































































































































































































































































    int $i$f$trimEnd;
    
























































































































































































































































































































































































































































































































































































































































    int i = $receiver$iv.length();i--; int index$iv; char p1; int $i$a$3$unknown; for (int j = 0; i >= 0; index$iv--) {
      p1 = $receiver$iv.charAt(index$iv);
    }
    return !CharsKt.isWhitespace(
    




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































      p1) ? 
      $receiver$iv.subSequence(0, index$iv + 1) : 
      
      (CharSequence)"";
  }
  
  @NotNull
  public static final java.util.List<String> split(@NotNull CharSequence $receiver, @NotNull String[] delimiters, boolean ignoreCase, int limit)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiters, "delimiters"); if (delimiters.length == 1) {
      String delimiter = delimiters[0];
      localObject1 = (CharSequence)delimiter; if ((((CharSequence)localObject1).length() == 0 ? 1 : 0) == 0) {
        return split$StringsKt__StringsKt($receiver, delimiter, ignoreCase, limit);
      }
    }
    
    Iterable $receiver$iv = kotlin.sequences.SequencesKt.asIterable(rangesDelimitedBy$StringsKt__StringsKt$default($receiver, delimiters, 0, ignoreCase, limit, 2, null));
    













































































































    int $i$f$map;
    













































































































    Object localObject1 = $receiver$iv;Collection destination$iv$iv = (Collection)new java.util.ArrayList(kotlin.collections.CollectionsKt.collectionSizeOrDefault($receiver$iv, 10));
    int $i$f$mapTo; Iterable $receiver$iv$iv; Collection localCollection1; String str1; for (java.util.Iterator localIterator = $receiver$iv$iv.iterator(); localIterator.hasNext(); localCollection1.add(str1))
    {





























































































































































































































      Object item$iv$iv = localIterator.next();
      IntRange localIntRange1 = (IntRange)item$iv$iv;localCollection1 = destination$iv$iv;
      int $i$a$1$map;
      IntRange it;
      str1 = StringsKt.substring($receiver, it);
    }
    






























































































































































































































    return (java.util.List)destination$iv$iv;
  }
  
  @NotNull
  public static final java.util.List<String> split(@NotNull CharSequence $receiver, @NotNull char[] delimiters, boolean ignoreCase, int limit)
  {
    Intrinsics.checkParameterIsNotNull($receiver, "receiver$0");Intrinsics.checkParameterIsNotNull(delimiters, "delimiters"); if (delimiters.length == 1) {
      return split$StringsKt__StringsKt($receiver, String.valueOf(delimiters[0]), ignoreCase, limit);
    }
    
    Iterable $receiver$iv = kotlin.sequences.SequencesKt.asIterable(rangesDelimitedBy$StringsKt__StringsKt$default($receiver, delimiters, 0, ignoreCase, limit, 2, null));
    



































































































    int $i$f$map;
    


































































































    Iterable localIterable1 = $receiver$iv;Collection destination$iv$iv = (Collection)new java.util.ArrayList(kotlin.collections.CollectionsKt.collectionSizeOrDefault($receiver$iv, 10));
    int $i$f$mapTo; Iterable $receiver$iv$iv; Collection localCollection1; String str; for (java.util.Iterator localIterator = $receiver$iv$iv.iterator(); localIterator.hasNext(); localCollection1.add(str))
    {








































































































































































































      Object item$iv$iv = localIterator.next();
      IntRange localIntRange1 = (IntRange)item$iv$iv;localCollection1 = destination$iv$iv;
      int $i$a$2$map;
      IntRange it;
      str = StringsKt.substring($receiver, it);
    }
    









































































































































































































    return (java.util.List)destination$iv$iv;
  }
  
  /* Error */
  @InlineOnly
  private static final String orEmpty(@org.jetbrains.annotations.Nullable String $receiver)
  {
    // Byte code:
    //   0: aload_0
    //   1: dup
    //   2: ifnull +6 -> 8
    //   5: goto +6 -> 11
    //   8: pop
    //   9: ldc 79
    //   11: areturn
    // Line number table:
    //   Java source line #273	-> byte code offset #0
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	12	0	$receiver	String
    //   0	12	1	$i$f$orEmpty	int
  }
  
  /* Error */
  public static final boolean hasSurrogatePairAt(@NotNull CharSequence $receiver, int index)
  {
    // Byte code:
    //   0: aload_0
    //   1: ldc 9
    //   3: invokestatic 15	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
    //   6: aload_0
    //   7: invokeinterface 23 1 0
    //   12: iconst_2
    //   13: isub
    //   14: iconst_0
    //   15: iload_1
    //   16: istore_2
    //   17: iload_2
    //   18: if_icmple +7 -> 25
    //   21: pop
    //   22: goto +43 -> 65
    //   25: iload_2
    //   26: if_icmplt +39 -> 65
    //   29: aload_0
    //   30: iload_1
    //   31: invokeinterface 27 2 0
    //   36: istore_2
    //   37: iload_2
    //   38: invokestatic 241	java/lang/Character:isHighSurrogate	(C)Z
    //   41: ifeq +24 -> 65
    //   44: aload_0
    //   45: iload_1
    //   46: iconst_1
    //   47: iadd
    //   48: invokeinterface 27 2 0
    //   53: istore_2
    //   54: iload_2
    //   55: invokestatic 244	java/lang/Character:isLowSurrogate	(C)Z
    //   58: ifeq +7 -> 65
    //   61: iconst_1
    //   62: goto +4 -> 66
    //   65: iconst_0
    //   66: ireturn
    // Line number table:
    //   Java source line #313	-> byte code offset #6
    //   Java source line #314	-> byte code offset #6
    //   Java source line #315	-> byte code offset #6
    //   Java source line #313	-> byte code offset #6
    //   Java source line #314	-> byte code offset #29
    //   Java source line #315	-> byte code offset #44
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	67	0	$receiver	CharSequence
    //   0	67	1	index	int
  }
  
  /* Error */
  private static final int indexOf$StringsKt__StringsKt(@NotNull CharSequence $receiver, CharSequence other, int startIndex, int endIndex, boolean ignoreCase, boolean last)
  {
    // Byte code:
    //   0: iload 5
    //   2: ifne +35 -> 37
    //   5: iload_2
    //   6: iconst_0
    //   7: invokestatic 520	kotlin/ranges/RangesKt:coerceAtLeast	(II)I
    //   10: istore 7
    //   12: new 231	kotlin/ranges/IntRange
    //   15: dup
    //   16: iload 7
    //   18: iload_3
    //   19: aload_0
    //   20: invokeinterface 23 1 0
    //   25: invokestatic 535	kotlin/ranges/RangesKt:coerceAtMost	(II)I
    //   28: invokespecial 234	kotlin/ranges/IntRange:<init>	(II)V
    //   31: checkcast 542	kotlin/ranges/IntProgression
    //   34: goto +19 -> 53
    //   37: iload_2
    //   38: aload_0
    //   39: invokestatic 464	kotlin/text/StringsKt:getLastIndex	(Ljava/lang/CharSequence;)I
    //   42: invokestatic 535	kotlin/ranges/RangesKt:coerceAtMost	(II)I
    //   45: iload_3
    //   46: iconst_0
    //   47: invokestatic 520	kotlin/ranges/RangesKt:coerceAtLeast	(II)I
    //   50: invokestatic 546	kotlin/ranges/RangesKt:downTo	(II)Lkotlin/ranges/IntProgression;
    //   53: astore 6
    //   55: aload_0
    //   56: instanceof 76
    //   59: ifeq +95 -> 154
    //   62: aload_1
    //   63: instanceof 76
    //   66: ifeq +88 -> 154
    //   69: aload 6
    //   71: dup
    //   72: dup
    //   73: invokevirtual 549	kotlin/ranges/IntProgression:getFirst	()I
    //   76: istore 7
    //   78: invokevirtual 552	kotlin/ranges/IntProgression:getLast	()I
    //   81: istore 8
    //   83: invokevirtual 555	kotlin/ranges/IntProgression:getStep	()I
    //   86: istore 9
    //   88: iload 7
    //   90: iload 8
    //   92: iload 9
    //   94: ifle +9 -> 103
    //   97: if_icmpgt +133 -> 230
    //   100: goto +6 -> 106
    //   103: if_icmplt +127 -> 230
    //   106: aload_1
    //   107: checkcast 76	java/lang/String
    //   110: iconst_0
    //   111: aload_0
    //   112: checkcast 76	java/lang/String
    //   115: iload 7
    //   117: aload_1
    //   118: invokeinterface 23 1 0
    //   123: iload 4
    //   125: invokestatic 559	kotlin/text/StringsKt:regionMatches	(Ljava/lang/String;ILjava/lang/String;IIZ)Z
    //   128: ifeq +6 -> 134
    //   131: iload 7
    //   133: ireturn
    //   134: iload 7
    //   136: iload 8
    //   138: if_icmpeq +92 -> 230
    //   141: iload 7
    //   143: iload 9
    //   145: iadd
    //   146: istore 7
    //   148: goto -42 -> 106
    //   151: nop
    //   152: nop
    //   153: athrow
    //   154: aload 6
    //   156: dup
    //   157: dup
    //   158: invokevirtual 549	kotlin/ranges/IntProgression:getFirst	()I
    //   161: istore 7
    //   163: invokevirtual 552	kotlin/ranges/IntProgression:getLast	()I
    //   166: istore 8
    //   168: invokevirtual 555	kotlin/ranges/IntProgression:getStep	()I
    //   171: istore 9
    //   173: iload 7
    //   175: iload 8
    //   177: iload 9
    //   179: ifle +9 -> 188
    //   182: if_icmpgt +48 -> 230
    //   185: goto +6 -> 191
    //   188: if_icmplt +42 -> 230
    //   191: aload_1
    //   192: iconst_0
    //   193: aload_0
    //   194: iload 7
    //   196: aload_1
    //   197: invokeinterface 23 1 0
    //   202: iload 4
    //   204: invokestatic 472	kotlin/text/StringsKt:regionMatchesImpl	(Ljava/lang/CharSequence;ILjava/lang/CharSequence;IIZ)Z
    //   207: ifeq +6 -> 213
    //   210: iload 7
    //   212: ireturn
    //   213: iload 7
    //   215: iload 8
    //   217: if_icmpeq +13 -> 230
    //   220: iload 7
    //   222: iload 9
    //   224: iadd
    //   225: istore 7
    //   227: goto -36 -> 191
    //   230: iconst_m1
    //   231: ireturn
    // Line number table:
    //   Java source line #865	-> byte code offset #0
    //   Java source line #866	-> byte code offset #5
    //   Java source line #868	-> byte code offset #37
    //   Java source line #865	-> byte code offset #53
    //   Java source line #870	-> byte code offset #55
    //   Java source line #871	-> byte code offset #69
    //   Java source line #872	-> byte code offset #106
    //   Java source line #873	-> byte code offset #131
    //   Java source line #871	-> byte code offset #134
    //   Java source line #876	-> byte code offset #154
    //   Java source line #877	-> byte code offset #191
    //   Java source line #878	-> byte code offset #210
    //   Java source line #876	-> byte code offset #213
    //   Java source line #880	-> byte code offset #230
    //   Java source line #881	-> byte code offset #230
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	232	0	$receiver	CharSequence
    //   0	232	1	other	CharSequence
    //   0	232	2	startIndex	int
    //   0	232	3	endIndex	int
    //   0	232	4	ignoreCase	boolean
    //   0	232	5	last	boolean
    //   55	177	6	indices	kotlin.ranges.IntProgression
    //   106	42	7	index	int
    //   191	36	7	index	int
  }
  
  /* Error */
  private static final kotlin.Pair<Integer, String> findAnyOf$StringsKt__StringsKt(@NotNull CharSequence $receiver, Collection<String> strings, int startIndex, boolean ignoreCase, boolean last)
  {
    // Byte code:
    //   0: iload_3
    //   1: ifne +75 -> 76
    //   4: aload_1
    //   5: invokeinterface 573 1 0
    //   10: iconst_1
    //   11: if_icmpne +65 -> 76
    //   14: aload_1
    //   15: checkcast 575	java/lang/Iterable
    //   18: invokestatic 580	kotlin/collections/CollectionsKt:single	(Ljava/lang/Iterable;)Ljava/lang/Object;
    //   21: checkcast 76	java/lang/String
    //   24: astore 5
    //   26: iload 4
    //   28: ifne +16 -> 44
    //   31: aload_0
    //   32: aload 5
    //   34: iload_2
    //   35: iconst_0
    //   36: iconst_4
    //   37: aconst_null
    //   38: invokestatic 306	kotlin/text/StringsKt:indexOf$default	(Ljava/lang/CharSequence;Ljava/lang/String;IZILjava/lang/Object;)I
    //   41: goto +13 -> 54
    //   44: aload_0
    //   45: aload 5
    //   47: iload_2
    //   48: iconst_0
    //   49: iconst_4
    //   50: aconst_null
    //   51: invokestatic 325	kotlin/text/StringsKt:lastIndexOf$default	(Ljava/lang/CharSequence;Ljava/lang/String;IZILjava/lang/Object;)I
    //   54: istore 6
    //   56: iload 6
    //   58: ifge +7 -> 65
    //   61: aconst_null
    //   62: goto +13 -> 75
    //   65: iload 6
    //   67: invokestatic 583	java/lang/Integer:valueOf	(I)Ljava/lang/Integer;
    //   70: aload 5
    //   72: invokestatic 589	kotlin/TuplesKt:to	(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
    //   75: areturn
    //   76: iload 4
    //   78: ifne +31 -> 109
    //   81: iload_2
    //   82: iconst_0
    //   83: invokestatic 520	kotlin/ranges/RangesKt:coerceAtLeast	(II)I
    //   86: istore 6
    //   88: new 231	kotlin/ranges/IntRange
    //   91: dup
    //   92: iload 6
    //   94: aload_0
    //   95: invokeinterface 23 1 0
    //   100: invokespecial 234	kotlin/ranges/IntRange:<init>	(II)V
    //   103: checkcast 542	kotlin/ranges/IntProgression
    //   106: goto +15 -> 121
    //   109: iload_2
    //   110: aload_0
    //   111: invokestatic 464	kotlin/text/StringsKt:getLastIndex	(Ljava/lang/CharSequence;)I
    //   114: invokestatic 535	kotlin/ranges/RangesKt:coerceAtMost	(II)I
    //   117: iconst_0
    //   118: invokestatic 546	kotlin/ranges/RangesKt:downTo	(II)Lkotlin/ranges/IntProgression;
    //   121: astore 5
    //   123: aload_0
    //   124: instanceof 76
    //   127: ifeq +152 -> 279
    //   130: aload 5
    //   132: dup
    //   133: dup
    //   134: invokevirtual 549	kotlin/ranges/IntProgression:getFirst	()I
    //   137: istore 6
    //   139: invokevirtual 552	kotlin/ranges/IntProgression:getLast	()I
    //   142: istore 7
    //   144: invokevirtual 555	kotlin/ranges/IntProgression:getStep	()I
    //   147: istore 8
    //   149: iload 6
    //   151: iload 7
    //   153: iload 8
    //   155: ifle +9 -> 164
    //   158: if_icmpgt +267 -> 425
    //   161: goto +6 -> 167
    //   164: if_icmplt +261 -> 425
    //   167: aload_1
    //   168: checkcast 575	java/lang/Iterable
    //   171: astore 10
    //   173: aload 10
    //   175: invokeinterface 592 1 0
    //   180: astore 11
    //   182: aload 11
    //   184: invokeinterface 597 1 0
    //   189: ifeq +48 -> 237
    //   192: aload 11
    //   194: invokeinterface 600 1 0
    //   199: astore 12
    //   201: aload 12
    //   203: checkcast 76	java/lang/String
    //   206: astore 13
    //   208: aload 13
    //   210: iconst_0
    //   211: aload_0
    //   212: checkcast 76	java/lang/String
    //   215: iload 6
    //   217: aload 13
    //   219: invokevirtual 311	java/lang/String:length	()I
    //   222: iload_3
    //   223: invokestatic 559	kotlin/text/StringsKt:regionMatches	(Ljava/lang/String;ILjava/lang/String;IIZ)Z
    //   226: ifeq -44 -> 182
    //   229: aload 12
    //   231: goto +7 -> 238
    //   234: nop
    //   235: nop
    //   236: athrow
    //   237: aconst_null
    //   238: checkcast 76	java/lang/String
    //   241: astore 9
    //   243: aload 9
    //   245: ifnull +14 -> 259
    //   248: iload 6
    //   250: invokestatic 583	java/lang/Integer:valueOf	(I)Ljava/lang/Integer;
    //   253: aload 9
    //   255: invokestatic 589	kotlin/TuplesKt:to	(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
    //   258: areturn
    //   259: iload 6
    //   261: iload 7
    //   263: if_icmpeq +162 -> 425
    //   266: iload 6
    //   268: iload 8
    //   270: iadd
    //   271: istore 6
    //   273: goto -106 -> 167
    //   276: nop
    //   277: nop
    //   278: athrow
    //   279: aload 5
    //   281: dup
    //   282: dup
    //   283: invokevirtual 549	kotlin/ranges/IntProgression:getFirst	()I
    //   286: istore 6
    //   288: invokevirtual 552	kotlin/ranges/IntProgression:getLast	()I
    //   291: istore 7
    //   293: invokevirtual 555	kotlin/ranges/IntProgression:getStep	()I
    //   296: istore 8
    //   298: iload 6
    //   300: iload 7
    //   302: iload 8
    //   304: ifle +9 -> 313
    //   307: if_icmpgt +118 -> 425
    //   310: goto +6 -> 316
    //   313: if_icmplt +112 -> 425
    //   316: aload_1
    //   317: checkcast 575	java/lang/Iterable
    //   320: astore 10
    //   322: aload 10
    //   324: invokeinterface 592 1 0
    //   329: astore 11
    //   331: aload 11
    //   333: invokeinterface 597 1 0
    //   338: ifeq +48 -> 386
    //   341: aload 11
    //   343: invokeinterface 600 1 0
    //   348: astore 12
    //   350: aload 12
    //   352: checkcast 76	java/lang/String
    //   355: astore 13
    //   357: aload 13
    //   359: checkcast 19	java/lang/CharSequence
    //   362: iconst_0
    //   363: aload_0
    //   364: iload 6
    //   366: aload 13
    //   368: invokevirtual 311	java/lang/String:length	()I
    //   371: iload_3
    //   372: invokestatic 472	kotlin/text/StringsKt:regionMatchesImpl	(Ljava/lang/CharSequence;ILjava/lang/CharSequence;IIZ)Z
    //   375: ifeq -44 -> 331
    //   378: aload 12
    //   380: goto +7 -> 387
    //   383: nop
    //   384: nop
    //   385: athrow
    //   386: aconst_null
    //   387: checkcast 76	java/lang/String
    //   390: astore 9
    //   392: aload 9
    //   394: ifnull +14 -> 408
    //   397: iload 6
    //   399: invokestatic 583	java/lang/Integer:valueOf	(I)Ljava/lang/Integer;
    //   402: aload 9
    //   404: invokestatic 589	kotlin/TuplesKt:to	(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
    //   407: areturn
    //   408: iload 6
    //   410: iload 7
    //   412: if_icmpeq +13 -> 425
    //   415: iload 6
    //   417: iload 8
    //   419: iadd
    //   420: istore 6
    //   422: goto -106 -> 316
    //   425: aconst_null
    //   426: areturn
    // Line number table:
    //   Java source line #885	-> byte code offset #0
    //   Java source line #886	-> byte code offset #14
    //   Java source line #887	-> byte code offset #26
    //   Java source line #888	-> byte code offset #56
    //   Java source line #891	-> byte code offset #76
    //   Java source line #893	-> byte code offset #123
    //   Java source line #894	-> byte code offset #130
    //   Java source line #895	-> byte code offset #167
    //   Java source line #1415	-> byte code offset #173
    //   Java source line #895	-> byte code offset #208
    //   Java source line #1416	-> byte code offset #237
    //   Java source line #895	-> byte code offset #238
    //   Java source line #896	-> byte code offset #243
    //   Java source line #897	-> byte code offset #248
    //   Java source line #894	-> byte code offset #259
    //   Java source line #900	-> byte code offset #279
    //   Java source line #901	-> byte code offset #316
    //   Java source line #1417	-> byte code offset #322
    //   Java source line #901	-> byte code offset #357
    //   Java source line #1418	-> byte code offset #386
    //   Java source line #901	-> byte code offset #387
    //   Java source line #902	-> byte code offset #392
    //   Java source line #903	-> byte code offset #397
    //   Java source line #900	-> byte code offset #408
    //   Java source line #905	-> byte code offset #425
    //   Java source line #907	-> byte code offset #425
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	427	0	$receiver	CharSequence
    //   0	427	1	strings	Collection
    //   0	427	2	startIndex	int
    //   0	427	3	ignoreCase	boolean
    //   0	427	4	last	boolean
    //   26	50	5	string	String
    //   123	304	5	indices	kotlin.ranges.IntProgression
    //   56	20	6	index	int
    //   167	106	6	index	int
    //   316	106	6	index	int
    //   243	16	9	matchingString	String
    //   392	16	9	matchingString	String
    //   173	65	10	$receiver$iv	Iterable
    //   322	65	10	$receiver$iv	Iterable
    //   201	33	12	element$iv	Object
    //   350	33	12	element$iv	Object
    //   208	18	13	it	String
    //   357	18	13	it	String
    //   208	18	14	$i$a$1$firstOrNull	int
    //   357	18	14	$i$a$2$firstOrNull	int
    //   173	65	15	$i$f$firstOrNull	int
    //   322	65	15	$i$f$firstOrNull	int
  }
  
  /* Error */
  public static final int indexOfAny(@NotNull CharSequence $receiver, @NotNull Collection<String> strings, int startIndex, boolean ignoreCase)
  {
    // Byte code:
    //   0: aload_0
    //   1: ldc 9
    //   3: invokestatic 15	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
    //   6: aload_1
    //   7: ldc_w 614
    //   10: invokestatic 15	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
    //   13: aload_0
    //   14: aload_1
    //   15: iload_2
    //   16: iload_3
    //   17: iconst_0
    //   18: invokestatic 616	kotlin/text/StringsKt__StringsKt:findAnyOf$StringsKt__StringsKt	(Ljava/lang/CharSequence;Ljava/util/Collection;IZZ)Lkotlin/Pair;
    //   21: dup
    //   22: ifnull +19 -> 41
    //   25: invokevirtual 627	kotlin/Pair:getFirst	()Ljava/lang/Object;
    //   28: checkcast 254	java/lang/Integer
    //   31: dup
    //   32: ifnull +9 -> 41
    //   35: invokevirtual 257	java/lang/Integer:intValue	()I
    //   38: goto +5 -> 43
    //   41: pop
    //   42: iconst_m1
    //   43: ireturn
    // Line number table:
    //   Java source line #952	-> byte code offset #13
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	44	0	$receiver	CharSequence
    //   0	44	1	strings	Collection
    //   0	44	2	startIndex	int
    //   0	44	3	ignoreCase	boolean
  }
  
  /* Error */
  public static final int lastIndexOfAny(@NotNull CharSequence $receiver, @NotNull Collection<String> strings, int startIndex, boolean ignoreCase)
  {
    // Byte code:
    //   0: aload_0
    //   1: ldc 9
    //   3: invokestatic 15	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
    //   6: aload_1
    //   7: ldc_w 614
    //   10: invokestatic 15	kotlin/jvm/internal/Intrinsics:checkParameterIsNotNull	(Ljava/lang/Object;Ljava/lang/String;)V
    //   13: aload_0
    //   14: aload_1
    //   15: iload_2
    //   16: iload_3
    //   17: iconst_1
    //   18: invokestatic 616	kotlin/text/StringsKt__StringsKt:findAnyOf$StringsKt__StringsKt	(Ljava/lang/CharSequence;Ljava/util/Collection;IZZ)Lkotlin/Pair;
    //   21: dup
    //   22: ifnull +19 -> 41
    //   25: invokevirtual 627	kotlin/Pair:getFirst	()Ljava/lang/Object;
    //   28: checkcast 254	java/lang/Integer
    //   31: dup
    //   32: ifnull +9 -> 41
    //   35: invokevirtual 257	java/lang/Integer:intValue	()I
    //   38: goto +5 -> 43
    //   41: pop
    //   42: iconst_m1
    //   43: ireturn
    // Line number table:
    //   Java source line #967	-> byte code offset #13
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	44	0	$receiver	CharSequence
    //   0	44	1	strings	Collection
    //   0	44	2	startIndex	int
    //   0	44	3	ignoreCase	boolean
  }
  
  public StringsKt__StringsKt() {}
}
